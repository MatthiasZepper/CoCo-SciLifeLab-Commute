---
title: 'SciLifeLab Commute: I want to ride my bicycle'
author: "Matthias Zepper"
date: "12/4/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
 
## Prepare the work environment

```{r message=FALSE, warning=FALSE}
if(!(require("osmdata") &
     require("sf") &
     require("raster") &
     require("rgdal") &
     require("mapdeck") &
     require("dodgr") &
     require("geodist"))) {
  
  
  # using the mirror of the Umeå University's Academic Computer Club
  # Choose a sensible one near you
  options(repos = c(CRAN = "https://ftp.acc.umu.se/mirror/CRAN/")) 
  install.packages(c("osmdata","sf", "raster", "rgdal", "mapdeck", "dodgr","geodist"))

  }

if (!dir.exists ("data")) {
  dir.create ("data")
}

# Setting to download data anew - even if already present
config_download_data <- FALSE
config_enrich_elevation <- FALSE
config_path_geotiffs <- "./data/nh_01_Stockholms_lan_Sweref_99_TM_geotiff"
```

## Obtain a street map of Stockholm
### Query Open Street Map's Overpass API
To calculate routes or perform other forms of analysis, we need a base map of Stockholm. We will use data from [Open Street Map](openstreetmap.org), which we obtain via the [OverpassAPI](https://wiki.openstreetmap.org/wiki/Overpass_API).

Its description reads: "*The Overpass API is a read-only API that serves up custom selected parts of the OSM map data. It acts as a database over the web: the client sends a query to the API and gets back the data set that corresponds to the query. Unlike the main API, which is optimized for editing, Overpass API is optimized for data consumers that need a few elements within a glimpse or up to roughly 10 million elements in some minutes, both selected by search criteria like e.g. location, type of objects, tag properties, proximity, or combinations of them. It acts as a database backend for various services.*"

Cool, that sounds like exactly what we need! However, like is the case with most powerful APIs, querying is quite cumbersome. [Overpass Turbo](https://overpass-turbo.eu) is a nice web application that you can use to interactively build queries. However, advantageously the R-package [`osmdata`](https://cran.r-project.org/web/packages/osmdata/index.html) provides a tremendously user-friendly interface to Overpass in R. 

It provides the `opq` function that constructs an *over pass query* for us: 

```{r}
library("osmdata")
osmdata::opq ("stockholm se")
```

The `opq` function works based on a bounding box of geospatial coordinates. Under the hood, it therefore calls the `getbb` function to derive a bounding box from a name or query based on an importance-ranked return:

```{r}
sthlm <- osmdata::getbb(place_name = "Stockholm", format_out = "data.frame")
print(sthlm[,c("display_name","importance")])
```
Thus it is advisable to verify if your bounding box coordinates in `bbox`  are sensible! 

At a latitude of 60°, Δ1°<sub>lat</sub> corresponds to ~111km, whereas Δ1°<sub>long</sub> represents ~56km ([see Wikipedia for details](https://en.wikipedia.org/wiki/Longitude#Length_of_a_degree_of_longitude)). Hence, this query downloads map data for a rectangle of 637km<sup>2</sup>.

```{r}
coordinates <-
  scan(textConnection(opq ("stockholm se")$bbox), sep = ",")
print(paste0(
  "ΔLatitude: ",
  diff(coordinates[c(1, 3)]) * 111.412,
  "km; ΔLongitude: ",
  diff(coordinates[c(2, 4)]) * 55.8,
  "km"
))
```
### Select data format and features of interest

Unless your query refers to some poorly mapped area e.g. in Siberia, such a square comprises **a lot** of data. For a densely populated city like Stockholm, we should therefore reduce the query to data that we will need and e.g. drop all buildings. 

Navigable paths, routes, and ways are all tagged within OSM as *highway*, readily enabling an overpass query to return only ways that can be used for routing purposes. Thus, we can restrict the query to highways only:  

```{r}
osmdata::opq("stockholm se") %>%
  osmdata::add_osm_feature (key = "highway")
```

This would however also include motorways and other routes that are exclusively or preferably usable by vehicles. The routing algorithm that we will use later can apply *weights* to roads reflecting preferences and thus we must not be overly concerned if we happen to download motorways, because with a weighting profile for cyclists will penalize routes along motorways so heavily that they will anyway be eliminated.  

Nonetheless, we can save some data and reduce computing time if we already restrict your street network to a more bicycle-friendly query!

OSM contains comprehensive annotations and thus [distinguishes many different features](https://wiki.openstreetmap.org/wiki/Map_features) such as *biergarten* or *nudism*. Within `osmdata` available features can be listed by `available_features()`. For a more cyclist-focused query we might want to use something like:

```{r}
osmdata::opq("stockholm se") %>%
  osmdata::add_osm_feature(key = "bicycle") %>%
  osmdata::add_osm_feature(key = "cycleway")
```

Multiple `add_osm_feature()` calls will however be interpreted as a logical *AND*, which will narrow down features just too easy and we might end up with an empty response from the API.  

Logical *OR* conjunctions can be made with `add_osm_features()`. Mind that features must be enclosed in escape-delimited quotations, so adding `\"` is mandatory.  

```{r}
osmdata::opq("stockholm se") %>%
  osmdata::add_osm_features(
    features = c(
        "\"amenity\"=\"bicycle_parking\"",
        "\"cycleway\"=\"lane\"",
        "\"cycleway\"=\"track\"",
        "\"highway\"=\"cycleway\"",
        "\"highway\"=\"secondary\"",
        "\"highway\"=\"tertiary\"",
        "\"highway\"=\"residential\"",
        "\"highway\"=\"unclassified\"",
        "\"highway\"=\"traffic_signals\"",
        "\"route\"=\"bicycle\""
    )
  )
```

`route=bicycle` comprises all routes useable by cyclists and may go along roads, trails or dedicated cycle paths. Many fine-grained `key=value` combinations for the features are possible. See the corresponding [Bicycle page in the OSM Wiki](https://wiki.openstreetmap.org/wiki/Bicycle).

### Downloading the data

Up until now, we have constructed a query to the Overpass API that comprises the *Where?* (within the bounding box) and the *What?* (features of interest). 

Now we need to specify the format of the response. The data may be returned in a variety of formats, currently including XML, R Spatial (sp), Simple Features (sf) and Silicate (SC). 

Each of the formats has various advantages and disadvantages and may not fully support each downstream application. Simple Features (sf) is a widespread format used by many different geo-applications and is therefore recommended as default. However, not all OSM data can be coerced into Simple Features and [thus some representational data loss occurs](https://docs.ropensci.org/osmdata/articles/osm-sf-translation.html). 

In contrast, [Silicate](https://github.com/hypertidy/silicate) can accommodate all information, such that `osmdata_sc()` function delivers a representation that is entirely faithful to the underlying OSM representation. It may not be supported by all downstream analysis tools, though. Therefore we will download the data twice in the Simple Features format for creating visualizations and in the Silicate Format for downstream analysis.   

```{r}
if (!file.exists ("data/Silicate_sthlm_map_cycle.Rds") |
    !file.exists ("data/SimpleFeatures_sthlm_map_cycle.Rds") |
    config_download_data) {
  sthlm_map_cycle <- osmdata::opq("stockholm se") %>%
    osmdata::add_osm_feature (key = "ISO3166-2", value = "SE-AB") %>%  
    osmdata::add_osm_features(
      features = c(
        "\"amenity\"=\"bicycle_parking\"",
        "\"cycleway\"=\"lane\"",
        "\"cycleway\"=\"track\"",
        "\"highway\"=\"cycleway\"",
        "\"highway\"=\"secondary\"",
        "\"highway\"=\"tertiary\"",
        "\"highway\"=\"residential\"",
        "\"highway\"=\"unclassified\"",
        "\"highway\"=\"traffic_signals\"",
        "\"route\"=\"bicycle\""
      )
    )
    
  sthlm_map_cycle_sc  <- osmdata::osmdata_sc(sthlm_map_cycle)
  sthlm_map_cycle_sf  <- osmdata::osmdata_sf(sthlm_map_cycle)
  
  # also download the states border for visualization
  sthlm_bdry <- opq ("stockholm se") %>%
        osmdata::add_osm_feature (key = "boundary", value = "administrative") %>%
        osmdata::add_osm_feature (key = "ISO3166-2", value = "SE-AB") %>%
        osmdata::osmdata_sf()
  sthlm_bdry <- sthlm_bdry$osm_multipolygons
    
  saveRDS(sthlm_map_cycle_sc, file = "data/Silicate_sthlm_map_cycle.Rds")
  saveRDS(osmdata::trim_osmdata(
    sthlm_map_cycle_sf,
    osmdata::getbb("SE-AB", format_out = "polygon")[[1]],
    exclude = TRUE
  ),
  file = "data/SimpleFeatures_sthlm_map_cycle.Rds")
  saveRDS(sthlm_bdry, file = "data/SimpleFeatures_sthlm_bdry.Rds")
  
} else {
  sthlm_map_cycle_sc <- readRDS("data/Silicate_sthlm_map_cycle.Rds")
  sthlm_map_cycle_sf <- readRDS("data/SimpleFeatures_sthlm_map_cycle.Rds")
  sthlm_bdry <- readRDS("data/SimpleFeatures_sthlm_bdry.Rds")
}
```

### Enrich the street map with elevation data

One of the advantages of using the Silicate format, the native format of the  offered by the `osmdata` package, is enabling elevation data to be combined with OSM data. Obviously, routing on street networks that accounts for elevation changes is quite advantageous for cyclists.

However, even though Open Street Map contains comprehensive data, elevation data is not part of OSM catalog. To exemplify, let*s take a sneak peak into our data bundle downloaded from the OSM Overpass API. It contains 127260 vertices, each with a longitude `x_` and a latitude `y_`, but lacking elevation data `z_`:

```{r}
head(sthlm_map_cycle_sc$vertex, n=3) 
```

Therefore, if we wish to consider elevation data for routing, we need to obtain it from another source and integrate it with our cycle map. The `osmdata` package can integrate elevation data in GeoTIFF format, an extended image file format that represents elevation as grayscale values. 

One option is the [CGIAR-CSI SRTM dataset](https://srtm.csi.cgiar.org/srtmdata), a post-processed derivation of the finished-grade 3 arc-second SRTM data released by the *National Aeronautics and Space Administration* (NASA) and distributed by the *United States Geological Survey* (USGS). Since it is based on satellite data, it lacks information for areas that are rarely overflown by satellites. In northern Europe, the boundary of this dataset is at about 60° latitude. Stockholm is therefore still covered (albeit at a low resolution), but not northern Sweden. Its resolution is also pretty low for routing within cities, all bridges are for example considered to be almost on sea level.  

Hence, if possible other sources of GeoTIFF files should be considered. In 2019 the [Lantmäteriet](https://geoforum.se/nyheter/34-infrastruktur-for-geodata/3844-nationella-hoejdmodellen-aer-klar) created a new reference dataset. [For Göteborg, the Swedish Data Portal hosts an excerpt](https://www.dataportal.se/en/datasets/66_70974/hojdmodell-geotiff) that is freely available. High resolution data for Stockholm can be accessed for educational purposes with a SWAMID account at the [GET service](https://www.lantmateriet.se/globalassets/dokumentarkiv/samverkan/forskning-utbildning-och-kultur/get2howto.pdf) or [as open data with a 50m resolution after registering a user account at the Lantmäteriet ](https://www.lantmateriet.se/en/maps-and-geographic-information/open-geodata/#faq=feef).


However, if you try to simply add the `nh_01_Stockholms_lan_Sweref_99_TM_geotiff` (or any other data set from Lantmäteriet) you will unfortunately fail:

```{r eval=FALSE}
if(config_enrich_elevation) {
  for (elevfile in list.files(config_path_geotiffs,
                              pattern = "[0-9].tif",
                              full.names = TRUE)) {
    sthlm_map_cycle_scevl <-
      osmdata::osm_elevation(sthlm_map_cycle_sc, elev_file = elevfile)
    
     saveRDS(sthlm_map_cycle_scevl, file = "data/Silicate_sthlm_map_cycle_elevation.Rds")
  }
}
```
 
The reason is, that our earth is of course not flat and in order to coerce geographical information into a two-dimensional representation like a flat image file, a projection needs to be used. Most [Swedish datasets make use of the SWEREF99 coordinate system](https://www.lantmateriet.se/en/maps-and-geographic-information/gps-geodesi-och-swepos/Referenssystem/Tredimensionella-system/SWEREF-99/). This is Swedens national coordinate system, and can only be used in and around Sweden. In order to use these coordinates together with software that works with the WGS84 coordinate system, an internationally widely used standard that also OSM adheres to, [conversion using a Gauss-Kreuger projection](https://pap.as/sweref/) is needed.

Some software can do the transformation on the fly, if the appropriate sidecar file with spatial information is provided (the accompanying .tfw files in the folder), but `osm_elevation` depends solely on the GeoTIFF header, so a prior conversion of the TIFF files e.g. with [`gdalwarp`](https://gdal.org/programs/gdalwarp.html) is necessary. Integration into R is offered by the [`gdalio`](https://github.com/hypertidy/gdalio) package.

As a final result, we will have a `z_` variable containing the elevation in meters for each vertex:

```{r}
if (!exists("sthlm_map_cycle_scelv") &
    file.exists ("data/Silicate_sthlm_map_cycle_elevation.Rds")) {
  sthlm_map_cycle_scevl <-
    readRDS("data/Silicate_sthlm_map_cycle_elevation.Rds")
}

head(sthlm_map_cycle_scevl$vertex, n=3) 

```

## Vizualising the downloaded Open Street Map data

Rendering a map out of the downloaded information:

```{r eval=FALSE}
if (exists("sthlm_map_cycle_sf")) {
  library("mapdeck")
  set_token (Sys.getenv("MAPBOX_TOKEN"))
  mapdeck (style = 'mapbox://styles/mapbox/light-v9') %>%
    mapdeck::add_path (data = sthlm_map_cycle_sf$osm_lines,
              stroke_width = 1,
              stroke_colour = "#4c979f",
              stroke_opacity = 0.6,
              layer_id = "lines")  %>%
  mapdeck::add_path (data = sthlm_map_cycle_sf$osm_multilines,
              stroke_width = 1,
              stroke_colour = "#4c979f",
              stroke_opacity = 1,
              layer_id = "multilines")
}
```

### Visualize the elevation data


```{r}
if (exists("sthlm_map_cycle_scevl") &
    is.null("sthlm_map_cycle_scevl$edgesmap")) {
  library("dplyr")
  
  sthlm_map_cycle_scevl$edgesmap <-
    dplyr::left_join (sthlm_map_cycle_scevl$edge,
                      sthlm_map_cycle_scevl$vertex,
                      by = c (".vx0" = "vertex_")) %>%
    dplyr::filter(x_ >= 17.7 & y_ <= 59.7) %>%
    dplyr::rename (".vx0_x" = x_,
                   ".vx0_y" = y_,
                   ".vx0_z" = z_) %>%
    dplyr::left_join (sthlm_map_cycle_scevl$vertex, by = c (".vx1" = "vertex_")) %>%
    dplyr::filter(x_ >= 17.7 & y_ <= 59.7) %>%
    dplyr::rename (".vx1_x" = x_,
                   ".vx1_y" = y_,
                   ".vx1_z" = z_) %>%
    dplyr::mutate ("zmn" = (.vx0_z + .vx1_z) / 2) %>%
    dplyr::select (-c (.vx0_z, .vx1_z))
  
} else {
  if (!is.null("sthlm_map_cycle_scevl$edgesmap")) {
    head(sthlm_map_cycle_scevl$edgesmap, n = 3)
  }
}  
```

```{r eval=FALSE}
if (!is.null("sthlm_map_cycle_scevl$edgesmap")) {
library("mapdeck")
set_token (Sys.getenv("MAPBOX_TOKEN"))
mapdeck (style = 'mapbox://styles/mapbox/light-v9') %>%
  mapdeck::add_line (
    sthlm_map_cycle_scevl$edgesmap,
    origin = c (".vx0_x", ".vx0_y"),
    destination = c (".vx1_x", ".vx1_y"),
    stroke_colour = "zmn",
    stroke_width=1.5,
    tooltip="zmn",
    palette = "topo",
    legend = TRUE,
    layer_id = "elevation"
  )
}
```

## Determine popular cycle routes to the SciLifeLab

Now that we have obtained a road map from OSM, it is time to simulate movement within this network.

Therefore, we will convert the map to a graph consisting of nodes and edges and applying a routing algorithm to determine the best connection between two nodes of that network. Several packages in R like [`igraph`](https://igraph.org/r/) provide some functionality to calculate distances on directed graphs, but we will use `dodgr`. This R package allows for an efficient calculation of many-to-many pairwise distances on dual-weighted directed graphs.

### Building and weighting the network

Dual-weighting is highly relevant for street networks, because the optimal route is not necessarily the shortest one. Therefore, we need to consider additional factors
that reflect preferences: Weighted distances for pedestrians on multi-lane vehicular roads are longer than equivalent distances along isolated walking paths and for cyclists steep elevations are longer than downhill slopes. Therefore `dodgr` assigns *weighted distances* depending on mode of transport and implements routing through street networks with various modes of transport, and using either distance- or time-based routing. Routing can include such factors as waiting times at traffic
lights, delays for turning across oncoming traffic, access restrictions, and the effects of elevation on both cyclists and pedestrians.

`dodgr` comes with a set of preconfigured *weighting_profiles* for the most common types of traffic that happens on street networks: 

```{r}
library("dodgr")
unique(dodgr::weighting_profiles$weighting_profiles$name)
```
<sub>*hgv* heavy goods vehicle = lorry, truck; *psv* is a public service vehicle = e.g. busses.</sub>

The profile for cyclists mostly considers the type of road and the road surface and also traffic lights: 

```{r}
library("dodgr")
lapply(dodgr::weighting_profiles, dplyr::filter, name=="bicycle")  
```

The profiles can be used to modify the weights of the edges upon converting the street map into a graph: 

```{r}
library("dodgr")
sthlm_graph_cycle_scevl <- dodgr::weight_streetnet (sthlm_map_cycle_scevl, wt_profile = "bicycle", turn_penalty = TRUE)
sthlm_graph_cycle_sc <- dodgr::weight_streetnet (sthlm_map_cycle_sc, wt_profile = "bicycle", turn_penalty = TRUE)
```  

Our resulting graph for Stockholm contains about half a million edges. The one generated from the map with elevation information has one additional column `dz`  for *distance in z*.  

```{r}
dim(sthlm_graph_cycle_scevl)
setdiff(colnames(sthlm_graph_cycle_scevl),colnames(sthlm_graph_cycle_sc))
``` 

The elevation does neither affect the physical distances nor the weighted distances (which incorporate the type of route e.g. primary road vs. cycleway) within the graph:

```{r}
summary(sthlm_graph_cycle_scevl$d/sthlm_graph_cycle_sc$d)
summary(sthlm_graph_cycle_scevl$d_weighted/sthlm_graph_cycle_sc$d_weighted)
``` 

The elevation may however affect the time and the time_weighted columns, although I am slightly skeptical about the 89 fold increase in time here:

```{r}
summary(sthlm_graph_cycle_scevl$time/sthlm_graph_cycle_sc$time)
summary(sthlm_graph_cycle_scevl$time_weighted/sthlm_graph_cycle_sc$time_weighted)
``` 

Investigate the outliers:

```{r}
sthlm_graph_cycle_scevl$travel_time_factors <- sthlm_graph_cycle_scevl$time/sthlm_graph_cycle_sc$time
outliers_extreme <- dplyr::filter(as.data.frame(sthlm_graph_cycle_scevl), travel_time_factors > 30) 
summary(outliers_extreme$d)
summary(outliers_extreme$dz/outliers_extreme$d)
``` 

The outliers are apparently very short edges (between 1-9m), but typically have a z-distance between that is 3 to 8 times greater. So the prolonged travel times are probably justified for almost vertical routes (unless you are into speed climbing), but clearly attributable to errors in the elevation data. Therefore, we will correct the times for those edges from the corresponding graph without elevation and later visualize them on the map to manually investigate.

```{r}
index_travel_time_outliers <- sthlm_graph_cycle_scevl$travel_time_factors > 5
index_travel_time_outliers[is.na(index_travel_time_outliers)] <- TRUE # also replace values for NA 
sthlm_graph_cycle_scevl[index_travel_time_outliers ,"time"] <- unlist(sthlm_graph_cycle_sc[index_travel_time_outliers ,"time"])
sthlm_graph_cycle_scevl[index_travel_time_outliers ,"time_weighted"] <- unlist(sthlm_graph_cycle_sc[index_travel_time_outliers ,"time_weighted"])
``` 